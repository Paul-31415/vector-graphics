
import { Vector } from "./vectors";



class WeightedVector<T extends Vector<any>> implements Vector<WeightedVector<T>> {
    public v: T;
    constructor(V: T, public w = 1, d = false) { if (!d) { this.v = V.scale(w); } else { this.v = V; } }
    copy(): Vector<WeightedVector<T>> {
        return new WeightedVector<T>(this.v.copy(), this.w);
    }
    add(o: Vector<WeightedVector<T>>): Vector<WeightedVector<T>> {
        return new WeightedVector<T>(this.v.add(o.v), this.w + o.w, true)

    }
    scale(s: number): Vector<WeightedVector<T>> {
        return new WeightedVector<T>(this.v.scale(s), this.w * s, true);
    }
    zero(): Vector<WeightedVector<T>> {
        return new WeightedVector<T>(this.v.zero(), 0, true);
    }
}



class Bezier<T extends Vector<any>> implements Vector<Bezier<T>> {
    constructor(public controlPoints: T[]) {
    }
    order(): number {
        return this.controlPoints.length - 1;
    }

    copy(): Vector<Bezier<T>> {
        var c2 = new Array<T>();
        for (var i = 0; i < this.controlPoints.length; i++) {
            c2.concat(this.controlPoints[i].copy());
        }
        return new Bezier<T>(c2);
    }
    add(o: Vector<Bezier<T>>): Vector<Bezier<T>> {
        if (o.order() > this.order()) {
            return this.incOrder().add(o);
        } else {
            if (o.order() < this.order()) {
                return o.incOrder().add(this);
            }
            else {

                var c2 = new Array<T>();
                for (var i = 0; i < this.controlPoints.length; i++) {
                    c2.concat(this.controlPoints[i].add(o.controlPoints[i]));
                }
                return new Bezier<T>(c2);
            }
        }
    }
    zero(): Vector<Bezier<T>> {
        return new Bezier<T>([this.controlPoints[0].zero()]);

    }
    scale(n: number): Vector<Bezier<T>> {
        var c2 = new Array<T>();
        for (var i = 0; i < this.controlPoints.length; i++) {
            c2.concat(this.controlPoints[i].scale(n));
        }
        return new Bezier<T>(c2);
    }

    get(t: number): T {
        if (this.order() == 0) {
            return this.controlPoints[0].copy();
        }
        var res = this.controlPoints[0].zero();
        var bin = 1;
        for (var i = 0; i < this.controlPoints.length; i++) {
            res = res.add(this.controlPoints[i].scale(
                bin *
                Math.pow((1 - t), this.order() - i) *
                Math.pow(t, i)
            ));
            bin *= (this.order() - i) / (i + 1);
        }
        return res;
    }
    incOrder(): Bezier<T> {
        const n = this.order();
        const k = n + 1;
        var v = new Array<T>();
        v[0] = this.controlPoints[0].copy();
        v[k] = this.controlPoints[n].copy();
        for (var i = 1; i <= n; i++) {
            v[i] = this.controlPoints[i].scale(n - i + 1).add(this.controlPoints[i - 1].scale(i)).scale(1 / k);
        }
        return new Bezier<T>(v);
    }



}



export {
    Bezier, WeightedVector
}
