3d stuff is hard, so lets just try to get volume-tracing/ray-tracing down with gpujs
so: make drawable stuff have to have something properly gpujs-ey
eg like make a point spline calc it's vertices in parallel then put them on the screen
and hey, lets try to use webgl for the fast-view.



[ ] seperate ui stuff from math/render stuff



[•] make it good at 2d art
  [•] tools:
    [•] brush
	[ ] curve editor
	[ ] selector
	[ ] curve tool (like brush but each click adds a point, not a curve)

[ ] make a plugin system
[ ] make most of these features part of a standard plugin set

core features:
[ ] drawing & animating
  [ ] draw
  [ ] edit
  [ ] erase
  [ ] animate
[ ] saveing
[ ] loading
[ ] 3d movement
[ ] rendering to video
[ ] (plugin system)

things not core:
[ ] lighting
[ ] physics
  [ ] fixed-length splines






b-spline idea:
  knot vector: each knot has a pointer to an array of the controlpoints that define it's region
                 use accessors and stuff to maintain it while also having a full-size controlpoint array
				 spline extension:
				    knots also have a multiplicity number instead of having multiple knots in the same place
					 this changes the connectedness between the sub arrays. This controls the continuity at
					 each knot
					knots also have a degree which specifies the degree of it's region (so one doesn't have
					 to have a 5th order representation of a 2nd order funciton eg)
					two modes of addition:
					 standard b-spline addition - (for unweighted vectors) (a+b)(t) = a(t)+b(t)
					 knot-sliding addition - for interpolation in which knots should slide around


capitalize all class names properly

[√] implement saving [ ] improve ui
[ ] make saving safe 

make transforms less annoying to deal with

intensify cacheing
- for fixed-length splines, cache length
- for all complex drawables, cache the PIXI.Graphics 
  • maybe make drawable subclass PIXI.Graphics
- cache lighting calculations for a given scene (later)

[ ] refactor brushes to use point generators
- fixed-length spline would have a point generator included that would refine (and cache) the length estimate


[•] class State:
  [√] saveable
  [ ] undo history/tree
  [•] interface in state
    [√] freecam
    [ ] buttons n stuff
    [ ] tools
	[ ] time
      [ ] figure out implementation
  [ ] cameras
  [ ] render cacheing
  [ ] views
    [ ] simple fast rendering for movement fluidity etc
	  [ ] hse
	  [ ] fake shading to show 3d
	  [ ] refine when still
        [ ] small angle approx
		  [ ] rerender priorities based on max visual error and time cost
           -  perhaps could tint all things needing to be rerendered
	[ ] 3d modes
      [ ] none/normal
	   -  percepturally realistic:
	    [ ] mirrors in the scene
		[ ] multiple views
	  [ ] stereo anaglyph
	     - can get away with using normal render + tint?
	  [ ] cross eyes
	   -  for shaders with things like outlines, have a
	      seperately defined viewcam to create those
		  outlines from but actually render it from a different cam
	  [ ] single image stereogram (but how to do color?)
	  [ ] shutterglasses
	  [ ] wobble
      [ ] head tracking for pan/short range movements?



[ ] make a proper interface
- make a button
- make some sliders maybe
- brush/color select
  • instead of fg and bg colors, have a variable length ring structure that can be cycled by pressing x and ⇧x

keep support for multi-touch
add support for Tongseng / other methods of getting multitouch with a trackpad
if possible, provide support for trackpad-multitouch without external dependencies

make more tools
- selector/editor
- paintbrush
- tool plugins/dynamics
  - something the tool takes as an arg that modifies the output? (or make a point tool and point acceptors and a curve cunstructor that is a point acceptor)

make more splines
- fixed-length spline has a number of free points that are moved by it to approach a desired length
- physics spline has along-curve properties like mass and stiffness and stretchyness etc. and can time-evolve

non-curves/fractal-paths
- eg for lightning, horisons, coastlines, etc

make more brushes
- SphereBrush : looks like the surface of the volume of points within a sphere of size p.s.width at any Point p on the curve.
  • importanceDistance - render distance within which all parts of the path render at least 1 pixel thick

allow more general transformations
- linear vs nonlinear distinction?
- invertable vs not distinction?
- Curve-basis transformation
- Curve<Curve<Curve<Point>>> transformation

Camera object?
- visual transformations


make smearframes work



macro/scripting language?

plugin API

game engine?
- high level instructions for fast keyframing of rough animation of scenes through gameplay

add lighting engine

custom material shaders

add sound engine

auto lipsync

add rendering engine

add hyperspectral color support

add sound wavetracing engine






Done:

make vector types support memory efficient operations (eg: scaleEq, addEq, zeroEq) √

useful papers:
http://artis.imag.fr/~Cyril.Soler/DEA/Ombres/Papers/Arvo.Sig87.pdf
 - add time to ray degrees of freedom for standard rendering
 - for funky ray tracing (like relativistic ray tracing), more degrees of freedom (e.g. solid angle to 3d vector that represents distance traveled in 1 time unit)
